# 函数

## 变量存储类型和标示符周期

**1.自动存储类型**:包括自动变量和寄存器变量

自动变量:auto,通常省略,块执行时,系统自动分配空间,块结束自动释放空间,空间通常分配在栈中

寄存器变量:register 如:register int n;这样的变量保存在寄存器中但不同的编译器对哪些变量可以说明为寄存器变量有不同的规定，而且一般的编译器都会对寄存器的使用进行优化，所以不提倡使用寄存器变量。

**2.静态存储类型**:static 均存储在全局数据区,系统自动初始化为全0,且初始化仅一次;静态变量占用的空间要整个程序执行结束才释放且分为"局部(内部)静态变量","全局(外部)静态变量",局部静态变量是定义在块中的静态变量,该空间一直到整个程序执行结束才释放==该变量具有局部作用域但却具有全局生命期==

**3.外部存储类型:**extern

- 程序中定义的全局变量和函数默认为外部的存储类型,其作用域可以延伸到==程序的其他文件==  
- 外部声明通常放在文件开头(函数总是省略extern)
- 同一个文件中,如果函数使用到了定义在函数之后的全局变量,也必须对使用的全局变量进行外部声明,以满足先定义后声明的原则,==所以全局变量最好居中在文件的起始部位==
- 外部变量声明不同于全局变量定义.变量定义时，编译器为其分配内存空间，而变量声明则表示该全局变量已在其他地方定义过，编译器不再分配内存空间，直接使用变量定义时所分配的空间。因此，所声明变量的变量名和类型必须与定义的完全相同。

## 标示符的生命期

生命期与存储区域相关,存储区域分为*代码区,静态数据区,栈区堆区*.相应地生命期分为*静态生命期,局部生命期,动态生命期*.

**1.静态生命期**

- 存放在==静态数据区,属于静态存储类型==,如静态全局变量,全局变量,静态局部变量
- 具有静态生命区的标示符在未被用户初始化的情况下会自动初始化为0
- 程序结束时消亡
- 所有具有文件作用域的标示符都具有静态生命期
- 文件驻留在代码区也具有静态生命期.

**2.局部生命期:**

- 函数内部或块中定义的标识符具有局部生命期,开始于执行到该函数或块的标识符的声明处,结束于函数或块的结束处

  具有局部生命期的标识符

  - 存放在栈区
  - 如果没被初始化,则内容是随机的,不可用.
  - 比具有局部作用域,反之不然,静态局部变量具有局部作用域,但却具有静态生命期

**3.动态生命期**

- 具有动态生命期的标识符有特定的函数调用或运算来创建或释放,如:调用malloc()或用new运算符为变量分配存储空间时,变量的生命期开始;而调用free()或delete运算符释放空间或结束时,变量生命期结束.
- 具有动态生命期的变量==存放在堆区==

## 函数的重载

相当于Java方法的重写

若需要定义几个功能相似,参数类型不同的函数,那么这样的函数可以起同一个名字

当遇到重载函数时,编译器根据实参的类型对应地调用相应地函数

匹配过程如下:

1.若参数严格匹配(参数个数类型完全一致),就调用该函数

2.参数通过类型转换后匹配

3.参数通过用户定义的类型转换寻求匹配

定义重载函数时必须保证参数的类型或个数不同,仅仅返回值类型不同是不行的



## 默认参数

存在默认参数的函数可以形参和实参的个数不同,默认参数为形参指定默认值,

注意:

- 默认参数不一定是常量表达式,可以是任意表达式,则函数每次被调用时该表达式重新求值,但表达式必须有意义

  ```c++
  int fun1(a = rand());
  ```

- 默认参数还可以是全局常量全局变量,函数调用给出,但不能通过全局变量给出

- 默认参数可以多个,需放在参数表的右侧

- 一个参数只可以指定一个默认值,即使一样也不行

## 内联函数

定义函数时使用修饰词 inline

**作用**:程序执行函数调用时需要系统时间和空间的开销,即使是简单的函数,只要使用的频率很高,花费的时间就会变多,从而程序执行效率降低,

提高效率的方法:一种是不使用函数直接将代码写入主函数,不可行,所以实用内联函数

eg:

```c++
# include <iostream.h>
inline IsNumber(char ch) { //因使用频度很高，说明为内联函数
    return ch>=′0′&&ch<=′9′?1:0;
}
void main(){
    char ch;
    while(ch=cin.get(ch)!= ′\n′){
        if (IsNumber(ch)) cout<<″是数字字符 ″<<endl;//内联函数的调用不特殊
        else cout<<″不是数字字符 ″<<endl;
    }
}
```

## 预编译处理

### 宏定义指令

- 不带参数的宏定义:用来产生与一个字符串(即宏名)对应的常量字符串,格式为:

  #define 宏名 常量串

- 带参数的宏定义:

  #define 宏名 (形参表) 表达式串

- 处理过程:编译预处理后产生一个中间文件，文件中所有宏名（如果是带参数的宏，则宏名包括参数表在内）均用其对应的常量串或表达式串代替。替换过程称为“宏替换”或“宏展开”。

注意:

- 宏替换只是字符串和标识符的替换,预处理本身不做任何数据类型和合法性的检查,也不分配内存单元

- 形参需要括号阔起来,否则导致逻辑错误

  如: #define S(a,b) a*b/2

  那么程序S(3+5,4+2)会宏展开为 3+5*4+2/2 ,不复方二真正的意图

- 带参宏定义形式上象定义函数，但它与函数的本质不同。宏定义只是产生字符串替代，不存在分配内存和参数传递。

### 文件包含指令

两种方式:

1. #include <文件名>
2. #include "文件名"     适用于自制的头文件

一个被包含的头文件中还可以有#include指令，即include指令可以嵌套。但是，如果同一个头文件在同一个源程序文件中被重复包含，就会出现标识符重复定义的错误。

 例如：头文件f2.h中包含了f1.h，如果文件f3.cpp中既包含f1.h，又包含f2.h，那么编译将提示错误，原因是f1.h被包含了两次，那么其中定义的标识符在f3.cpp中就被重复定义。

### 条件编译指令

当希望不同的条件下编译程序的不同部分,这种情况需要"条件编译"指令

包括: ==#if,#else,#ifdef,#ifndef,#endif,#undef==等

分为两类:

1. 用宏名作为编译的条件

   ​	#ifdef <宏名>

   ​	<程序段1>

   ​	[#else

   ​	<程序段2>]

   ​	#endif

2. 用表达式的值作为编译条件:

   ​	#if<表达式>

   ​	<程序段1>

   ​	[#else

   ​	<程序段2>]

   ​	#endif

程序段可以是程序也可以是编译预处理命令

一定要有#endif



